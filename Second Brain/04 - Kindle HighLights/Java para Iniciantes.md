---
tags: highlights
type: kindleHighlights
kindle-sync:
  bookId: '21644'
  title: Java para Iniciantes (Portuguese Edition)
  author: Luiz Duarte
  asin: B01MY7VBE5
  lastAnnotatedDate: '2022-05-01'
  bookImageUrl: 'https://m.media-amazon.com/images/I/81khWwYeXEL._SY160.jpg'
  highlightsCount: 167
---
# Java para Iniciantes
![Capa|120](https://m.media-amazon.com/images/I/81khWwYeXEL._SY160.jpg)
## Metadata
* Author: [Luiz Duarte](https://www.amazon.com/-/pt/Luiz-Duarte/e/B01IM2GM7M/ref=dp_byline_cont_ebooks_1)

* ASIN: B01MY7VBE5




* Reference: https://www.amazon.com/dp/B01MY7VBE5
* [Kindle link](kindle://book?action=open&asin=B01MY7VBE5)

## Highlights 167
```ad-note
title: Location [127](kindle://book?action=open&asin=B01MY7VBE5&location=127)
icon: location
color: 251 201 87

introduzida no mercado na década de 90 pela Sun Microsystems, ^ref-5708

```
```ad-note
title: Location [129](kindle://book?action=open&asin=B01MY7VBE5&location=129)
icon: location
color: 251 201 87

No início dos anos 2000, a empresa Sun foi comprada pela Oracle, fazendo com que o Java mudasse de dono mas sem perder o seu brilho e importância no mercado. ^ref-4001

```
```ad-note
title: Location [134](kindle://book?action=open&asin=B01MY7VBE5&location=134)
icon: location
color: 251 201 87

exibe as facilidades proporcionadas pela orientação à objetos, pela extrema portabilidade do código produzido, pelas características de segurança que esta plataforma oferece e finalmente pela facilidade ^ref-44593

```
```ad-note
title: Location [144](kindle://book?action=open&asin=B01MY7VBE5&location=144)
icon: location
color: 251 201 87

Java é uma linguagem puramente orientada à objetos pois, com exceção de seus tipos primitivos de dados, tudo em Java são classes ou instância de uma classe. ^ref-50239

```
```ad-note
title: Location [149](kindle://book?action=open&asin=B01MY7VBE5&location=149)
icon: location
color: 251 201 87

os programas Java são compilados para uma forma intermediária de código denominada bytecodes ^ref-32732

```
```ad-note
title: Location [151](kindle://book?action=open&asin=B01MY7VBE5&location=151)
icon: location
color: 251 201 87

Os bytecodes são como uma linguagem de máquina destinada a uma única plataforma, a máquina virtual Java ^ref-48685

```
```ad-note
title: Location [152](kindle://book?action=open&asin=B01MY7VBE5&location=152)
icon: location
color: 251 201 87

(JVM – Java Virtual Machine), ^ref-51912

```
```ad-note
title: Location [152](kindle://book?action=open&asin=B01MY7VBE5&location=152)
icon: location
color: 251 201 87

um interpretador de bytecodes. Pode-se implementar uma JVM para qualquer plataforma assim temos que um mesmo programa Java pode ser executado em qualquer arquitetura que disponha de uma JVM. ^ref-29278

```
```ad-note
title: Location [155](kindle://book?action=open&asin=B01MY7VBE5&location=155)
icon: location
color: 251 201 87

modelo de máquina virtual foi tão bem sucedido que diversas outras plataformas de desenvolvimento migraram para esta arquitetura, ^ref-1584

```
```ad-note
title: Location [158](kindle://book?action=open&asin=B01MY7VBE5&location=158)
icon: location
color: 251 201 87

Java não possui ponteiros, ^ref-59138

```
```ad-note
title: Location [158](kindle://book?action=open&asin=B01MY7VBE5&location=158)
icon: location
color: 251 201 87

Java não permite a manipulação direta de endereços de memória nem exige que o objetos criados sejam destruídos livrando os programadores de uma tarefa complexa. ^ref-38095

```
```ad-note
title: Location [160](kindle://book?action=open&asin=B01MY7VBE5&location=160)
icon: location
color: 251 201 87

JVM possui um mecanismo automático de gerenciamento de memória conhecido como ^ref-17252

```
```ad-note
title: Location [160](kindle://book?action=open&asin=B01MY7VBE5&location=160)
icon: location
color: 251 201 87

garbage collector (coletor de lixo), ^ref-35351

```
```ad-note
title: Location [160](kindle://book?action=open&asin=B01MY7VBE5&location=160)
icon: location
color: 251 201 87

que recupera a memória alocada para objetos não mais referenciados pelo programa. ^ref-2129

```
```ad-note
title: Location [162](kindle://book?action=open&asin=B01MY7VBE5&location=162)
icon: location
color: 251 201 87

maioria das linguagens modernas, tidas como de alto nível, nem mesmo tem permitido ou aconselhado o uso de ponteiros. ^ref-61246

```
```ad-note
title: Location [164](kindle://book?action=open&asin=B01MY7VBE5&location=164)
icon: location
color: 251 201 87

projetada para ser compacta, ^ref-50822

```
```ad-note
title: Location [165](kindle://book?action=open&asin=B01MY7VBE5&location=165)
icon: location
color: 251 201 87

plataforma e para utilização em rede ^ref-51602

```
```ad-note
title: Location [165](kindle://book?action=open&asin=B01MY7VBE5&location=165)
icon: location
color: 251 201 87

interpretada através dos esquema de bytecodes. ^ref-23970

```
```ad-note
title: Location [166](kindle://book?action=open&asin=B01MY7VBE5&location=166)
icon: location
color: 251 201 87

a performance é razoável, não podendo ser comparada a velocidade de execução de código nativo. ^ref-28047

```
```ad-note
title: Location [167](kindle://book?action=open&asin=B01MY7VBE5&location=167)
icon: location
color: 251 201 87

Para superar esta limitação várias JVM dispõem de compiladores ^ref-53192

```
```ad-note
title: Location [167](kindle://book?action=open&asin=B01MY7VBE5&location=167)
icon: location
color: 251 201 87

just in time (JIT) ^ref-61514

```
```ad-note
title: Location [167](kindle://book?action=open&asin=B01MY7VBE5&location=167)
icon: location
color: 251 201 87

que compilam os bytecodes para código nativo durante a execução otimizando a mesma, ^ref-3103

```
```ad-note
title: Location [169](kindle://book?action=open&asin=B01MY7VBE5&location=169)
icon: location
color: 251 201 87

faz toda a diferença quando você programa grandes aplicações, ^ref-58070

```
```ad-note
title: Location [172](kindle://book?action=open&asin=B01MY7VBE5&location=172)
icon: location
color: 251 201 87

Java possui mecanismos de segurança que podem evitar qualquer operação no sistema de arquivos da máquina-alvo, ^ref-43408

```
```ad-note
title: Location [218](kindle://book?action=open&asin=B01MY7VBE5&location=218)
icon: location
color: 251 201 87

necessária a instalação de alguns softwares visando não apenas o funcionamento, mas também a produtividade no aprendizado e desenvolvimento dos programas. ^ref-4197

```
```ad-note
title: Location [226](kindle://book?action=open&asin=B01MY7VBE5&location=226)
icon: location
color: 251 201 87

Mas apenas com o JRE instalado não estamos aptos a programar Java, apenas a executar softwares Java. ^ref-34772

```
```ad-note
title: Location [228](kindle://book?action=open&asin=B01MY7VBE5&location=228)
icon: location
color: 251 201 87

JDK, o Java Development Kit ou Kit de Desenvolvimento Java. ^ref-4285

```
```ad-note
title: Location [330](kindle://book?action=open&asin=B01MY7VBE5&location=330)
icon: location
color: 251 201 87

Esta instrução orienta que seja impresso uma linha (println) na saída (out) do sistema (System), linha essa que deve estar entre aspas dentro dos parênteses do comando println. ^ref-28051

```
```ad-note
title: Location [334](kindle://book?action=open&asin=B01MY7VBE5&location=334)
icon: location
color: 251 201 87

"package olaMundo" indica um pacote a que pertence esta classe, como se fosse uma pasta do sistema operacional, e servem para organizar os programa em Java. ^ref-8108

```
```ad-note
title: Location [349](kindle://book?action=open&asin=B01MY7VBE5&location=349)
icon: location
color: 251 201 87

public indica que esta classe/arquivo é pública, ou seja, pode ser invocada de qualquer ponto do programa. ^ref-4581

```
```ad-note
title: Location [352](kindle://book?action=open&asin=B01MY7VBE5&location=352)
icon: location
color: 251 201 87

class introduz uma definição de classe em Java, ou seja, define que aquele código entre as chaves será uma classe. Ela deve possuir o nome da classe à sua direita, no caso OlaMundo. ^ref-17707

```
```ad-note
title: Location [359](kindle://book?action=open&asin=B01MY7VBE5&location=359)
icon: location
color: 251 201 87

Os programas em Java sempre começam sua execução em um bloco de código main, ^ref-33476

```
```ad-note
title: Location [360](kindle://book?action=open&asin=B01MY7VBE5&location=360)
icon: location
color: 251 201 87

parênteses depois do main indicam que ele é um bloco de construção de programa chamado de método. ^ref-17316

```
```ad-note
title: Location [363](kindle://book?action=open&asin=B01MY7VBE5&location=363)
icon: location
color: 251 201 87

Se o método main não for escrito exatamente daquele jeito, o interpretador do Java não executará o programa. ^ref-7427

```
```ad-note
title: Location [365](kindle://book?action=open&asin=B01MY7VBE5&location=365)
icon: location
color: 251 201 87

public como já foi dito anteriormente, define o escopo do código dentro do programa, ou seja, público, qualquer um pode "chamar" esse código. ^ref-39415

```
```ad-note
title: Location [367](kindle://book?action=open&asin=B01MY7VBE5&location=367)
icon: location
color: 251 201 87

void indica que este método realizará uma ^ref-2167

```
```ad-note
title: Location [368](kindle://book?action=open&asin=B01MY7VBE5&location=368)
icon: location
color: 251 201 87

tarefa (neste caso, imprimir a linha de texto na tela) mas NÃO retornará informação alguma ao seu término. ^ref-20623

```
```ad-note
title: Location [370](kindle://book?action=open&asin=B01MY7VBE5&location=370)
icon: location
color: 251 201 87

"String args[]" dentro dos parênteses são argumentos passados para esse programa e são obrigatórios no main, embora não iremos utilizá-lo aqui. ^ref-60240

```
```ad-note
title: Location [372](kindle://book?action=open&asin=B01MY7VBE5&location=372)
icon: location
color: 251 201 87

As chaves esquerda e direita definem o escopo em programas Java, blocos de código. ^ref-7646

```
```ad-note
title: Location [374](kindle://book?action=open&asin=B01MY7VBE5&location=374)
icon: location
color: 251 201 87

Toda chave que abre deve possuir uma chave que fecha, "}", caso contrário teremos erro de compilação. ^ref-42597

```
```ad-note
title: Location [382](kindle://book?action=open&asin=B01MY7VBE5&location=382)
icon: location
color: 251 201 87

System.out, que significa "saída do sistema". ^ref-32068

```
```ad-note
title: Location [403](kindle://book?action=open&asin=B01MY7VBE5&location=403)
icon: location
color: 251 201 87

Em outras palavras, uma variável é como uma memória, capaz de armazenar um valor de um certo tipo, para a qual se dá um nome que usualmente descreve seu significado ou propósito. ^ref-24866

```
```ad-note
title: Location [405](kindle://book?action=open&asin=B01MY7VBE5&location=405)
icon: location
color: 251 201 87

Desta forma toda variável possui um nome, um tipo e um conteúdo. ^ref-26240

```
```ad-note
title: Location [409](kindle://book?action=open&asin=B01MY7VBE5&location=409)
icon: location
color: 251 201 87

linguagem Java é sensível ao ^ref-43923

```
```ad-note
title: Location [410](kindle://book?action=open&asin=B01MY7VBE5&location=410)
icon: location
color: 251 201 87

caixa empregado (case sensitive), ^ref-29721

```
```ad-note
title: Location [424](kindle://book?action=open&asin=B01MY7VBE5&location=424)
icon: location
color: 251 201 87

variável não pode utilizar como nome uma palavra reservada da linguagem. ^ref-47113

```
```ad-note
title: Location [474](kindle://book?action=open&asin=B01MY7VBE5&location=474)
icon: location
color: 251 201 87

Variáveis podem ser declaradas em qualquer ponto de um programa Java, ^ref-11982

```
```ad-note
title: Location [477](kindle://book?action=open&asin=B01MY7VBE5&location=477)
icon: location
color: 251 201 87

variáveis utilize nomes iniciados com letras minúsculas. Caso o nome seja composto de mais de uma palavras, as demais deveriam ser iniciadas com letras maiúsculas tal como nos exemplos: ^ref-55814

```
```ad-note
title: Location [484](kindle://book?action=open&asin=B01MY7VBE5&location=484)
icon: location
color: 251 201 87

oito tipos básicos de dados, ^ref-19804

```
```ad-note
title: Location [484](kindle://book?action=open&asin=B01MY7VBE5&location=484)
icon: location
color: 251 201 87

tipos primitivos, ^ref-46039

```
```ad-note
title: Location [566](kindle://book?action=open&asin=B01MY7VBE5&location=566)
icon: location
color: 251 201 87

o Java tem diversos outros tipos que não são considerados primitivos, mas derivados ou objetos. ^ref-38118

```
```ad-note
title: Location [568](kindle://book?action=open&asin=B01MY7VBE5&location=568)
icon: location
color: 251 201 87

classes denominadas wrappers que encapsulam os tipos primitivos como objetos da linguagem. O maior exemplo de tipo derivado que usamos no dia-a-dia é a String, utilizada para representar textos (mais do que um caractere). Mas falaremos disso mais tarde. ^ref-24958

```
```ad-note
title: Location [574](kindle://book?action=open&asin=B01MY7VBE5&location=574)
icon: location
color: 251 201 87

O Java aceita três tipos de comentários: de uma linha, de múltiplas linhas e de documentação. ^ref-30439

```
```ad-note
title: Location [575](kindle://book?action=open&asin=B01MY7VBE5&location=575)
icon: location
color: 251 201 87

uma linha utiliza duas barras (//) para marcar seu início: ^ref-61824

```
```ad-note
title: Location [579](kindle://book?action=open&asin=B01MY7VBE5&location=579)
icon: location
color: 251 201 87

/* e */ para delimitar uma ou mais linhas de comentários: ^ref-38852

```
```ad-note
title: Location [583](kindle://book?action=open&asin=B01MY7VBE5&location=583)
icon: location
color: 251 201 87

O último tipo é semelhante ao comentário de múltiplas linhas mas tem o propósito de documentar o programa: ^ref-5571

```
```ad-note
title: Location [590](kindle://book?action=open&asin=B01MY7VBE5&location=590)
icon: location
color: 251 201 87

Geralmente o comentário de documentação é posicionado imediatamente antes do elemento a ser documentado e tem seu conteúdo extraído automaticamente pelo utilitário javadoc ^ref-38481

```
```ad-note
title: Location [681](kindle://book?action=open&asin=B01MY7VBE5&location=681)
icon: location
color: 251 201 87

Java oferece um conjunto bastante amplo de operadores destinados a realização de operações aritméticas, lógicas, relacionais e de atribuição. ^ref-33268

```
```ad-note
title: Location [755](kindle://book?action=open&asin=B01MY7VBE5&location=755)
icon: location
color: 251 201 87

Java possui operadores relacionais, isto é, operadores que permitem comparar valores literais, variáveis ou o resultado de expressões retornando um resultado do tipo lógico, ^ref-38573

```
```ad-note
title: Location [771](kindle://book?action=open&asin=B01MY7VBE5&location=771)
icon: location
color: 251 201 87

Note que o operador igualdade é definido como sendo um duplo sinal de igual (==) que não deve ser confundido com o operador de atribuição, um sinal simples de igual (=), ^ref-20994

```
```ad-note
title: Location [807](kindle://book?action=open&asin=B01MY7VBE5&location=807)
icon: location
color: 251 201 87

operadores que permitem conectar logicamente o resultado de diferentes expressões aritméticas ou relacionais construindo assim uma expressão resultante composta de várias partes e portanto mais complexa. ^ref-16726

```
```ad-note
title: Location [832](kindle://book?action=open&asin=B01MY7VBE5&location=832)
icon: location
color: 251 201 87

Também podemos atribuir valores mais tarde, com valores literais ou como resultado de expressões. ^ref-33740

```
```ad-note
title: Location [845](kindle://book?action=open&asin=B01MY7VBE5&location=845)
icon: location
color: 251 201 87

Todos os tipos utilizados na linguagem Java, com exceção dos tipos primitivos ^ref-16197

```
```ad-note
title: Location [846](kindle://book?action=open&asin=B01MY7VBE5&location=846)
icon: location
color: 251 201 87

tipo String, com S maiúsculo, é um dos objetos mais utilizados, isso porque ele é utilizado para criar variáveis que guardam ^ref-34064

```
```ad-note
title: Location [847](kindle://book?action=open&asin=B01MY7VBE5&location=847)
icon: location
color: 251 201 87

texto dentro de si, algo muito recorrente em desenvolvimento de software. ^ref-56204

```
```ad-note
title: Location [848](kindle://book?action=open&asin=B01MY7VBE5&location=848)
icon: location
color: 251 201 87

char permite armazenar apenas um caracter por vez, ^ref-60088

```
```ad-note
title: Location [849](kindle://book?action=open&asin=B01MY7VBE5&location=849)
icon: location
color: 251 201 87

String permite armazenar um número virtualmente infinito de caracteres, ^ref-45436

```
```ad-note
title: Location [855](kindle://book?action=open&asin=B01MY7VBE5&location=855)
icon: location
color: 251 201 87

Isso porque valores de texto literais devem estar entre aspas (duplas) para serem considerados Strings. ^ref-4044

```
```ad-note
title: Location [857](kindle://book?action=open&asin=B01MY7VBE5&location=857)
icon: location
color: 251 201 87

se não declararmos o valor contido em uma String em sua inicialização, ela conterá null (nulo). O ideal é sempre inicializarmos nossas Strings, para não corrermos o risco de termos erros de execução mais pra frente. ^ref-50427

```
```ad-note
title: Location [875](kindle://book?action=open&asin=B01MY7VBE5&location=875)
icon: location
color: 251 201 87

Strings é que qualquer variável que a gente concatene com uma String, acaba gerando outra String ^ref-57553

```
```ad-note
title: Location [887](kindle://book?action=open&asin=B01MY7VBE5&location=887)
icon: location
color: 251 201 87

Note que isso não altera o tipo da variável idade ou seu valor, apenas faz uma cópia dela em forma de texto, automaticamente. ^ref-35412

```
```ad-note
title: Location [965](kindle://book?action=open&asin=B01MY7VBE5&location=965)
icon: location
color: 251 201 87

Naturalmente tais instruções são executadas em sequência, o que se denomina fluxo sequencial de execução. ^ref-58053

```
```ad-note
title: Location [967](kindle://book?action=open&asin=B01MY7VBE5&location=967)
icon: location
color: 251 201 87

em inúmeras circunstâncias é necessário executar as instruções de um programa em uma ordem diferente da estritamente sequencial. ^ref-51641

```
```ad-note
title: Location [974](kindle://book?action=open&asin=B01MY7VBE5&location=974)
icon: location
color: 251 201 87

Estruturas de repetição: ^ref-52856

```
```ad-note
title: Location [980](kindle://book?action=open&asin=B01MY7VBE5&location=980)
icon: location
color: 251 201 87

Estruturas de desvio de fluxo: ^ref-25969

```
```ad-note
title: Location [990](kindle://book?action=open&asin=B01MY7VBE5&location=990)
icon: location
color: 251 201 87

podem ser divididas entre simples e condicionais. ^ref-2435

```
```ad-note
title: Location [990](kindle://book?action=open&asin=B01MY7VBE5&location=990)
icon: location
color: 251 201 87

repetem um ou mais comandos Java durante um número de vezes definido na sua declaração ou baseado em uma expressão lógica, ^ref-35617

```
```ad-note
title: Location [999](kindle://book?action=open&asin=B01MY7VBE5&location=999)
icon: location
color: 251 201 87

O for (PARA) possui três campos ou seções, delimitados por um par de parênteses ^ref-10250

```
```ad-note
title: Location [1003](kindle://book?action=open&asin=B01MY7VBE5&location=1003)
icon: location
color: 251 201 87

O primeiro campo é usado para dar valor inicial a uma variável de controle ^ref-21043

```
```ad-note
title: Location [1007](kindle://book?action=open&asin=B01MY7VBE5&location=1007)
icon: location
color: 251 201 87

O segundo campo é uma expressão lógica que determina a execução da diretiva associada ao for, ^ref-2373

```
```ad-note
title: Location [1018](kindle://book?action=open&asin=B01MY7VBE5&location=1018)
icon: location
color: 251 201 87

incremento/decremento. Neste último campo nós mudamos o valor da variável de comando, para mais ou para menos. Esse incremento/decremento acontece uma vez a cada repetição do laço, ^ref-29816

```
```ad-note
title: Location [1127](kindle://book?action=open&asin=B01MY7VBE5&location=1127)
icon: location
color: 251 201 87

O do/while também é um laço condicional, isto é, tal como o while ^ref-26643

```
```ad-note
title: Location [1130](kindle://book?action=open&asin=B01MY7VBE5&location=1130)
icon: location
color: 251 201 87

diferentemente do while, a diretiva associada é executada antes da avaliação da expressão lógica e assim temos que esta diretiva é executada pelo menos uma vez. ^ref-43810

```
```ad-note
title: Location [1203](kindle://book?action=open&asin=B01MY7VBE5&location=1203)
icon: location
color: 251 201 87

Estudar algoritmos de programação é exatamente isso: entender que diversos caminhos levam à mesma solução. Cabe ao programador identificar qual o melhor, neste caso, o for. ^ref-19920

```
```ad-note
title: Location [1206](kindle://book?action=open&asin=B01MY7VBE5&location=1206)
icon: location
color: 251 201 87

forma como usei o incremento unário nestes exemplos. Note que incrementei o valor de x dentro de um println e dentro de uma estrutura while. ^ref-55015

```
```ad-note
title: Location [1208](kindle://book?action=open&asin=B01MY7VBE5&location=1208)
icon: location
color: 251 201 87

Temos dois operadores de incremento unário, o ++x e o x++. ^ref-17191

```
```ad-note
title: Location [1209](kindle://book?action=open&asin=B01MY7VBE5&location=1209)
icon: location
color: 251 201 87

O primeiro aumenta o valor de x em 1 e depois retorna o valor do mesmo, enquanto que o segundo retorna o valor de x e depois o aumenta em 1. Pode parecer uma pequena diferença, ^ref-1211

```
```ad-note
title: Location [1228](kindle://book?action=open&asin=B01MY7VBE5&location=1228)
icon: location
color: 251 201 87

else é uma estrutura simples de desvio de fluxo de execução, ^ref-16949

```
```ad-note
title: Location [1234](kindle://book?action=open&asin=B01MY7VBE5&location=1234)
icon: location
color: 251 201 87

if é SE. SE a expressão entre parênteses for verdade (true), então a diretiva1 será executada. Caso contrário, ela é ignorada. ^ref-49433

```
```ad-note
title: Location [1246](kindle://book?action=open&asin=B01MY7VBE5&location=1246)
icon: location
color: 251 201 87

assim como acontece nos laços de repetição, se vamos executar mais de uma diretiva, devemos agrupá-las dentro de chaves, ^ref-51994

```
```ad-note
title: Location [1269](kindle://book?action=open&asin=B01MY7VBE5&location=1269)
icon: location
color: 251 201 87

mod (apelido popular do % entre programadores) é fazer a divisão de um número pelo outro, mas ao invés de retornar o resultado, ele retorna o resto. ^ref-42122

```
```ad-note
title: Location [1316](kindle://book?action=open&asin=B01MY7VBE5&location=1316)
icon: location
color: 251 201 87

else é SENÃO, e ele define basicamente o caminho alternativo que seu programa tomará caso a condição do if não seja verdadeira, como abaixo. ^ref-16851

```
```ad-note
title: Location [1358](kindle://book?action=open&asin=B01MY7VBE5&location=1358)
icon: location
color: 251 201 87

apenas estudando e combinando os operadores lógico e relacionais, ^ref-46988

```
```ad-note
title: Location [1398](kindle://book?action=open&asin=B01MY7VBE5&location=1398)
icon: location
color: 251 201 87

se suas comparações são sempre de uma variável em relação a um valor, existe uma estrutura mais eficiente para isso: a switch/case. ^ref-20270

```
```ad-note
title: Location [1485](kindle://book?action=open&asin=B01MY7VBE5&location=1485)
icon: location
color: 251 201 87

Um array (também chamado de vetor em algumas linguagens de programação) é um tipo especial de objeto que permite que a gente armazene diversos valores de mesmo tipo dentro dele, cada um em uma posição de memória dentro do array. Quando criamos um array, dizemos o tipo e a quantidade máxima de elementos que ele poderá armazenar, todos de mesmo tipo. ^ref-12998

```
```ad-note
title: Location [1501](kindle://book?action=open&asin=B01MY7VBE5&location=1501)
icon: location
color: 251 201 87

Os elementos do array são numerados iniciando com zero (zero-based), ^ref-37894

```
```ad-note
title: Location [1505](kindle://book?action=open&asin=B01MY7VBE5&location=1505)
icon: location
color: 251 201 87

O número de elementos em um array é seu comprimento (length). Esse comprimento é especificado quando o array é criado e nunca muda seu tamanho. ^ref-25908

```
```ad-note
title: Location [1620](kindle://book?action=open&asin=B01MY7VBE5&location=1620)
icon: location
color: 251 201 87

Java é possível construirmos aplicações de console, ^ref-19365

```
```ad-note
title: Location [1622](kindle://book?action=open&asin=B01MY7VBE5&location=1622)
icon: location
color: 251 201 87

para a realização das operações de entrada de dados fornecidos pelo usuário e a exibição de mensagens do programa. ^ref-6659

```
```ad-note
title: Location [1624](kindle://book?action=open&asin=B01MY7VBE5&location=1624)
icon: location
color: 251 201 87

terminal entendemos as seções ou janelas em modo texto (que capazes de exibir apenas texto) de sistemas Unix, as janelas "Prompt do MS-DOS" existentes no Windows e outras semelhantes existentes nos demais sistemas operacionais. ^ref-63151

```
```ad-note
title: Location [1630](kindle://book?action=open&asin=B01MY7VBE5&location=1630)
icon: location
color: 251 201 87

Para construir-se aplicações de console basta uma classe (arquivo Java) onde seja definido o método main, ^ref-13720

```
```ad-note
title: Location [1632](kindle://book?action=open&asin=B01MY7VBE5&location=1632)
icon: location
color: 251 201 87

Este método é o primeiro a ser executado numa aplicação, daí ser estático, ou seja, não depende de mais nada no sistema para existir, apenas da própria classe (arquivo) em que se encontra, como uma espécie de método permanente, que sempre existe. ^ref-8494

```
```ad-note
title: Location [1640](kindle://book?action=open&asin=B01MY7VBE5&location=1640)
icon: location
color: 251 201 87

Sendo um método público (public), o main pode ser chamado de qualquer ponto da aplicação e até mesmo fora dela (pelo sistema operacional, por exemplo), ^ref-34445

```
```ad-note
title: Location [1647](kindle://book?action=open&asin=B01MY7VBE5&location=1647)
icon: location
color: 251 201 87

O bloco de código main também deve obrigatoriamente não retornar valores (void) e receber um array de String como argumento (String[] args). ^ref-50003

```
```ad-note
title: Location [1654](kindle://book?action=open&asin=B01MY7VBE5&location=1654)
icon: location
color: 251 201 87

aplicações de console utilizam como padrão a stream de dados out, disponível estaticamente através da classe System. ^ref-1961

```
```ad-note
title: Location [1657](kindle://book?action=open&asin=B01MY7VBE5&location=1657)
icon: location
color: 251 201 87

stream pode ser entendida como um duto capaz de transportar dados de um lugar (um arquivo ou dispositivo) para um outro lugar diferente. ^ref-25962

```
```ad-note
title: Location [1660](kindle://book?action=open&asin=B01MY7VBE5&location=1660)
icon: location
color: 251 201 87

A stream de saída padrão é aberta automaticamente pela máquina virtual Java (JVM) ^ref-46800

```
```ad-note
title: Location [1664](kindle://book?action=open&asin=B01MY7VBE5&location=1664)
icon: location
color: 251 201 87

Enquanto a stream de saída out é usada para enviar informações pro usuário, a stream de entrada in é usada para ler dados enviados por ele. ^ref-43921

```
```ad-note
title: Location [1673](kindle://book?action=open&asin=B01MY7VBE5&location=1673)
icon: location
color: 251 201 87

Imprime a variável ou valor literal passado dentro dos parênteses, podendo ser de qualquer tipo primitivo ou String ^ref-11172

```
```ad-note
title: Location [1675](kindle://book?action=open&asin=B01MY7VBE5&location=1675)
icon: location
color: 251 201 87

porém inclui uma quebra de linha no final do valor escrito (lê-se print line) ^ref-64990

```
```ad-note
title: Location [1683](kindle://book?action=open&asin=B01MY7VBE5&location=1683)
icon: location
color: 251 201 87

sobre a impressão (print) de dados na saída (out) do sistema (System). ^ref-24974

```
```ad-note
title: Location [1686](kindle://book?action=open&asin=B01MY7VBE5&location=1686)
icon: location
color: 251 201 87

toda aplicação de console possui uma stream associada para ser utilizada como saída padrão, existe uma outra stream denominada de entrada padrão, usualmente associada ao teclado do sistema. Essa stream, de nome in, disponível estaticamente através da classe System é também aberta automaticamente quando a aplicação é iniciada pela máquina virtual Java (JVM) ^ref-25299

```
```ad-note
title: Location [1694](kindle://book?action=open&asin=B01MY7VBE5&location=1694)
icon: location
color: 251 201 87

entrada destes dados são muito ruins, uma vez que são orientados a ler bytes "crus" (raw bytes). Desta maneira, geralmente utilizamos a entrada in em conjunto com algum outro objeto Java que nos permita uma leitura de dados mais prática, como a classe Scanner. ^ref-43961

```
```ad-note
title: Location [1704](kindle://book?action=open&asin=B01MY7VBE5&location=1704)
icon: location
color: 251 201 87

basta entender que com exceção dos tipos primitivos e das Strings, todo o resto precisa ser inicializado com a palavra reservada new (novo). ^ref-24739

```
```ad-note
title: Location [1758](kindle://book?action=open&asin=B01MY7VBE5&location=1758)
icon: location
color: 251 201 87

Isso porque quando o Scanner leu os 4 bytes que formam o inteiro digitado pelo usuário, ele deixou pra trás o ‘\n’ (Enter) ^ref-60530

```
```ad-note
title: Location [1759](kindle://book?action=open&asin=B01MY7VBE5&location=1759)
icon: location
color: 251 201 87

Na linha abaixo, como ele mandou ler uma linha (nextLine), o Scanner encontrou logo de cara um ‘\n’ (quebra de linha, Enter) "sobrando" no buffer do teclado e entendeu que a palavra já foi digitada. ^ref-17182

```
```ad-note
title: Location [1822](kindle://book?action=open&asin=B01MY7VBE5&location=1822)
icon: location
color: 251 201 87

pseudo-IA, usando números aleatórios ^ref-42999

```
```ad-note
title: Location [1824](kindle://book?action=open&asin=B01MY7VBE5&location=1824)
icon: location
color: 251 201 87

da CPU, usando a classe Math para isso. A classe Math contém diversas funções matemáticas, incluindo um gerador de números chamado random, ^ref-22718

```
```ad-note
title: Location [1827](kindle://book?action=open&asin=B01MY7VBE5&location=1827)
icon: location
color: 251 201 87

Como o que queremos é que a CPU "escolha" um número entre 1 e 2, teremos de fazer alguns ajustes, como arredondar o decimal gerado para o inteiro mais próximo (função ceil da classe Math) e depois somar com 1. ^ref-62215

```
```ad-note
title: Location [1880](kindle://book?action=open&asin=B01MY7VBE5&location=1880)
icon: location
color: 251 201 87

podemos "atrasar" a execução da tarefa usando o comando Thread.sleep(1000), que atrasa o processador em 1000ms (1 segundo). ^ref-26417

```
```ad-note
title: Location [1936](kindle://book?action=open&asin=B01MY7VBE5&location=1936)
icon: location
color: 251 201 87

Que tal um esquema de rounds ou melhor de 3? ^ref-45976

```
```ad-note
title: Location [1937](kindle://book?action=open&asin=B01MY7VBE5&location=1937)
icon: location
color: 251 201 87

criar um array de 3 posições para armazenar quem venceu cada um dos rounds e, se alguém levar 2 de 3, é o vencedor definitivo! ^ref-43396

```
```ad-note
title: Location [1941](kindle://book?action=open&asin=B01MY7VBE5&location=1941)
icon: location
color: 251 201 87

Vamos começar ajustando nosso algoritmo para incluir um array de rounds no início do algoritmo. Vou fazer um array de char, assim, guardo a letra J (jogador) ou C (cpu) indicando quem ganhou aquele round ^ref-21467

```
```ad-note
title: Location [1949](kindle://book?action=open&asin=B01MY7VBE5&location=1949)
icon: location
color: 251 201 87

assim que uma partida acaba, devemos salvar a letra inicial do vencedor dentro do array de rounds, na posição do roundAtual (e incrementando ele para o próximo round acontecer). ^ref-63948

```
```ad-note
title: Location [1982](kindle://book?action=open&asin=B01MY7VBE5&location=1982)
icon: location
color: 251 201 87

Que tal um laço de repetição em volta do algoritmo, que se repete três vezes? ^ref-25892

```
```ad-note
title: Location [1983](kindle://book?action=open&asin=B01MY7VBE5&location=1983)
icon: location
color: 251 201 87

Apenas certifique-se de colocar toda a lógica do jogo (exceto o array de rounds), dentro de um laço while como abaixo, ^ref-9282

```
```ad-note
title: Location [1997](kindle://book?action=open&asin=B01MY7VBE5&location=1997)
icon: location
color: 251 201 87

E se alguém ganhar 2 seguidas, nesse caso não precisa de 3 rounds, certo? ^ref-26283

```
```ad-note
title: Location [1998](kindle://book?action=open&asin=B01MY7VBE5&location=1998)
icon: location
color: 251 201 87

Não é muito difícil. Que tal se após a segunda partida/iteração do laço while (roundAtual == 2) a gente verifique se não há dois ganhadores repetidos no array? ^ref-4388

```
```ad-note
title: Location [2000](kindle://book?action=open&asin=B01MY7VBE5&location=2000)
icon: location
color: 251 201 87

Nesse caso bastaria encerrar o laço usando o comando break, ^ref-39347

```
```ad-note
title: Location [2219](kindle://book?action=open&asin=B01MY7VBE5&location=2219)
icon: location
color: 251 201 87

Raciocinando um pouco (e sugiro fazer isso sempre antes de começar a programar) ^ref-42802

```
```ad-note
title: Location [2304](kindle://book?action=open&asin=B01MY7VBE5&location=2304)
icon: location
color: 251 201 87

Testamos primeiro se houve empate ^ref-8670

```
```ad-note
title: Location [2304](kindle://book?action=open&asin=B01MY7VBE5&location=2304)
icon: location
color: 251 201 87

depois as três possíveis situações do jogador ganhar a partida, ^ref-62913

```
```ad-note
title: Location [2305](kindle://book?action=open&asin=B01MY7VBE5&location=2305)
icon: location
color: 251 201 87

caso contrário (senão), cair no else que dá a vitória para a máquina. ^ref-20847

```
```ad-note
title: Location [2308](kindle://book?action=open&asin=B01MY7VBE5&location=2308)
icon: location
color: 251 201 87

repetir o jogo automaticamente em caso de empate, você pode circundar todo o algoritmo dentro de um while infinito, ^ref-29845

```
```ad-note
title: Location [2309](kindle://book?action=open&asin=B01MY7VBE5&location=2309)
icon: location
color: 251 201 87

caso de vitória de alguém, usar a diretiva break ^ref-48503

```
```ad-note
title: Location [2312](kindle://book?action=open&asin=B01MY7VBE5&location=2312)
icon: location
color: 251 201 87

Temos ainda outro ajuste possível, que é o de simplificar o teste de quem ganhou, usando de lógica OU (OR) com a combinação das três situações possíveis de vitória por parte do jogador. ^ref-63911

```
```ad-note
title: Location [2385](kindle://book?action=open&asin=B01MY7VBE5&location=2385)
icon: location
color: 251 201 87

uso dos parênteses serviu para "isolar" cada uma das expressões AND (&&) que representam cada uma das possibilidades de vitória pro jogador. ^ref-36585

```
```ad-note
title: Location [2394](kindle://book?action=open&asin=B01MY7VBE5&location=2394)
icon: location
color: 251 201 87

Se qualquer uma das três condições for verdadeira, o fluxo de execução do algoritmo vai entrar no if. ^ref-25642

```
```ad-note
title: Location [2407](kindle://book?action=open&asin=B01MY7VBE5&location=2407)
icon: location
color: 251 201 87

Sendo um jogo originalmente de cartas, o primeiro passo é sempre construirmos o baralho. ^ref-47598

```
```ad-note
title: Location [2409](kindle://book?action=open&asin=B01MY7VBE5&location=2409)
icon: location
color: 251 201 87

vamos declarar um array com 52 posições, uma para cada carta do baralho. ^ref-52380

```
```ad-note
title: Location [2425](kindle://book?action=open&asin=B01MY7VBE5&location=2425)
icon: location
color: 251 201 87

encadeei dois laços for, ^ref-42962

```
```ad-note
title: Location [2426](kindle://book?action=open&asin=B01MY7VBE5&location=2426)
icon: location
color: 251 201 87

gerar 4 cartas de cada um dos 13 números. ^ref-36078

```
```ad-note
title: Location [2427](kindle://book?action=open&asin=B01MY7VBE5&location=2427)
icon: location
color: 251 201 87

usei uma expressão não usual para determinar em qual posição do array cada uma das cartas deveria estar, em ordem numérica, sem sobrepor nenhuma. ^ref-45703

```
```ad-note
title: Location [2428](kindle://book?action=open&asin=B01MY7VBE5&location=2428)
icon: location
color: 251 201 87

primeiras treze cartas vão ocupar as posições de 0 à 12, na sequência, graças ao cálculo que coloquei dentro do índice do array ^ref-61393

```
```ad-note
title: Location [2432](kindle://book?action=open&asin=B01MY7VBE5&location=2432)
icon: location
color: 251 201 87

nosso próximo passo, sempre que estivermos fazendo um jogo de cartas, é embaralhar as mesmas. ^ref-1939

```
```ad-note
title: Location [2433](kindle://book?action=open&asin=B01MY7VBE5&location=2433)
icon: location
color: 251 201 87

Não existe uma única maneira de fazer ^ref-6077

```
```ad-note
title: Location [2434](kindle://book?action=open&asin=B01MY7VBE5&location=2434)
icon: location
color: 251 201 87

na verdade em algoritmos nunca há uma única maneira de fazer, ^ref-21051

```
```ad-note
title: Location [2435](kindle://book?action=open&asin=B01MY7VBE5&location=2435)
icon: location
color: 251 201 87

Assim, para cada posição de uma carta do nosso array, vamos trocá-la de posição, aleatoriamente, com outra carta, usando um laço for simples. ^ref-46359

```
```ad-note
title: Location [2450](kindle://book?action=open&asin=B01MY7VBE5&location=2450)
icon: location
color: 251 201 87

você pode colocar um mais externo, para repetir o embaralhamento mais de uma vez, assim como fazemos em carteados tradicionais. ^ref-65026

```
```ad-note
title: Location [2451](kindle://book?action=open&asin=B01MY7VBE5&location=2451)
icon: location
color: 251 201 87

hora de sacarmos uma carta por vez, na ordem, enquanto o jogador quiser mais cartas, ao mesmo tempo em que somamos cada carta retirada do baralho à pontuação dele. ^ref-42280

```
```ad-note
title: Location [2485](kindle://book?action=open&asin=B01MY7VBE5&location=2485)
icon: location
color: 251 201 87

não poderia usar um for, uma vez que não sabemos de antemão quantas cartas o jogador vai querer sacar. Segundo, até poderíamos usar o while, mas se temos a certeza de que no mínimo uma carta vai ser sacada ^ref-41527

```
```ad-note
title: Location [2499](kindle://book?action=open&asin=B01MY7VBE5&location=2499)
icon: location
color: 251 201 87

Sabemos que maisCarta é uma variável booleana, que deve receber true ou false como únicos valores. No entanto, não precisamos escrever explicitamente true ou false à direita da atribuição (=), mas sim, qualquer expressão que resulte em true ou false. ^ref-43240

```
```ad-note
title: Location [2505](kindle://book?action=open&asin=B01MY7VBE5&location=2505)
icon: location
color: 251 201 87

Nesse ponto que aplicamos as regras do jogo, para saber se o jogador venceu ou não. ^ref-29200

```
```ad-note
title: Location [2526](kindle://book?action=open&asin=B01MY7VBE5&location=2526)
icon: location
color: 251 201 87

encerra com uma mensagem e um comando return, que significa ‘sai do main’, ao menos por enquanto. ;) ^ref-17911

```
```ad-note
title: Location [2531](kindle://book?action=open&asin=B01MY7VBE5&location=2531)
icon: location
color: 251 201 87

E por fim, o ponto mais curioso do código acima, se ele fez menos de 21 pontos, é a vez da ‘banca’ jogar. ^ref-5452

```
```ad-note
title: Location [2532](kindle://book?action=open&asin=B01MY7VBE5&location=2532)
icon: location
color: 251 201 87

dizer aqui, é que o próximo passo é a CPU jogar, para ver se ela vencerá a partida ou o jogador. ^ref-40675

```
```ad-note
title: Location [2534](kindle://book?action=open&asin=B01MY7VBE5&location=2534)
icon: location
color: 251 201 87

Basicamente a CPU vai sacar cartas com a seguinte lógica: ela quer fazer mais pontos que o jogador, ^ref-33030

```
```ad-note
title: Location [2535](kindle://book?action=open&asin=B01MY7VBE5&location=2535)
icon: location
color: 251 201 87

CPU fizer mais de 21 pontos, ela perde automaticamente. ^ref-27089

```
```ad-note
title: Location [2535](kindle://book?action=open&asin=B01MY7VBE5&location=2535)
icon: location
color: 251 201 87

menos pontos que o jogador, ela perde também. ^ref-4719

```
```ad-note
title: Location [2570](kindle://book?action=open&asin=B01MY7VBE5&location=2570)
icon: location
color: 251 201 87

criei uma variável para armazenar a pontuação da CPU ^ref-16747

```
```ad-note
title: Location [2571](kindle://book?action=open&asin=B01MY7VBE5&location=2571)
icon: location
color: 251 201 87

(afinal, não podemos usar a variável antiga para não perder o comparativo), ^ref-44854

```
```ad-note
title: Location [2574](kindle://book?action=open&asin=B01MY7VBE5&location=2574)
icon: location
color: 251 201 87

ao invés da tradicional pergunta se ela deseja sacar mais uma carta, a intrépida CPU se foca apenas em calcular se ainda pode ganhar ou não. ^ref-13663

```
```ad-note
title: Location [2579](kindle://book?action=open&asin=B01MY7VBE5&location=2579)
icon: location
color: 251 201 87

possibilidade de empate, caso o jogador e a CPU alcancem 21 pontos. Nesse caso quem tivesse tirado mais cartas ganharia, mas preferi dar a vitória para o jogador para simplificar, ^ref-53463

```
```ad-note
title: Location [2580](kindle://book?action=open&asin=B01MY7VBE5&location=2580)
icon: location
color: 251 201 87

iria requerer mais duas variáveis para mantermos controle, uma para o número de cartas sacada pelo jogador e outra para a CPU. ^ref-42569

```
```ad-note
title: Location [2582](kindle://book?action=open&asin=B01MY7VBE5&location=2582)
icon: location
color: 251 201 87

Outro ajuste que poderia ser feito, esse bem mais interessante, seria um esquema de apostas. ^ref-64011

```
```ad-note
title: Location [2583](kindle://book?action=open&asin=B01MY7VBE5&location=2583)
icon: location
color: 251 201 87

banca/CPU sempre cobriria a aposta do jogador. Ele poderia jogar indefinidas partidas, enquanto tivesse saldo. ^ref-53721

```
```ad-note
title: Location [2585](kindle://book?action=open&asin=B01MY7VBE5&location=2585)
icon: location
color: 251 201 87

para até 3 jogadores. Aqui teríamos de manter variáveis de pontos (e saldo, se estiver usando apostas) para cada um deles, fazer cada um jogar individualmente (cada um rodaria o primeiro do/while até o fim) e depois no final calcular quem ganhou. ^ref-53138

```
