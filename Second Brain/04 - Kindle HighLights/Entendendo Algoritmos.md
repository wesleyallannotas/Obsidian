---
tags: highlights
type: kindleHighlights
kindle-sync:
  bookId: '27829'
  title: >-
    Entendendo Algoritmos: Um guia ilustrado para programadores e outros
    curiosos (Portuguese Edition)
  author: Aditya Y. Bhargava
  asin: B07B61HC3L
  lastAnnotatedDate: '2022-09-21'
  bookImageUrl: 'https://m.media-amazon.com/images/I/91z0+pX2AkL._SY160.jpg'
  highlightsCount: 176
---
# Entendendo Algoritmos
![Capa|120](https://m.media-amazon.com/images/I/91z0+pX2AkL._SY160.jpg)
## Metadata
* Author: [Aditya Y. Bhargava](https://www.amazon.comundefined)

* ASIN: B07B61HC3L




* Reference: https://www.amazon.com/dp/B07B61HC3L
* [Kindle link](kindle://book?action=open&asin=B07B61HC3L)

## Highlights 176
```ad-note
title: Location [287](kindle://book?action=open&asin=B07B61HC3L&location=287)
icon: location
color: 251 201 87

Um algoritmo é um conjunto de instruções que realizam uma tarefa. ^ref-58229

```
```ad-note
title: Location [328](kindle://book?action=open&asin=B07B61HC3L&location=328)
icon: location
color: 251 201 87

A pesquisa binária é um algoritmo. Sua entrada é uma lista ordenada de elementos (explicarei mais tarde por que motivo a lista precisa ser ordenada). Se o elemento que você está buscando está na lista, a pesquisa binária retorna a sua localização. Caso contrário, a pesquisa binária retorna None. ^ref-56388

```
```ad-note
title: Location [341](kindle://book?action=open&asin=B07B61HC3L&location=341)
icon: location
color: 251 201 87

Isso se chama pesquisa simples (talvez pesquisa estúpida seja um termo melhor). A cada tentativa, você está eliminando apenas um número. ^ref-49497

```
```ad-note
title: Location [354](kindle://book?action=open&asin=B07B61HC3L&location=354)
icon: location
color: 251 201 87

Elimine metade dos números a cada tentativa com a pesquisa binária. ^ref-31696

```
```ad-note
title: Location [369](kindle://book?action=open&asin=B07B61HC3L&location=369)
icon: location
color: 251 201 87

Logaritmos são o oposto de exponenciais. ^ref-45897

```
```ad-note
title: Location [372](kindle://book?action=open&asin=B07B61HC3L&location=372)
icon: location
color: 251 201 87

quando falamos sobre a notação Big O (explicada daqui a pouco), levamos em conta que log sempre significa log2. ^ref-29931

```
```ad-note
title: Location [384](kindle://book?action=open&asin=B07B61HC3L&location=384)
icon: location
color: 251 201 87

A pesquisa binária só funciona quando a sua lista está ordenada. Por exemplo, os nomes em uma agenda telefônica estão em ordem alfabética, então você pode utilizar a pesquisa binária para procurar um nome. ^ref-47214

```
```ad-note
title: Location [388](kindle://book?action=open&asin=B07B61HC3L&location=388)
icon: location
color: 251 201 87

buckets são numerados a partir do 0: o primeiro bucket está na posição #0; o segundo, em #1; o terceiro, em #2, e assim por diante. ^ref-42900

```
```ad-note
title: Location [453](kindle://book?action=open&asin=B07B61HC3L&location=453)
icon: location
color: 251 201 87

Logo, o número máximo de tentativas é igual ao tamanho da lista. Isso é chamado de tempo linear. ^ref-47774

```
```ad-note
title: Location [456](kindle://book?action=open&asin=B07B61HC3L&location=456)
icon: location
color: 251 201 87

pesquisa binária é executada com tempo logarítmico. ^ref-13165

```
```ad-note
title: Location [460](kindle://book?action=open&asin=B07B61HC3L&location=460)
icon: location
color: 251 201 87

A notação Big O é uma notação especial que diz o quão rápido é um algoritmo. ^ref-64612

```
```ad-note
title: Location [484](kindle://book?action=open&asin=B07B61HC3L&location=484)
icon: location
color: 251 201 87

o tempo de execução da pesquisa simples e da pesquisa binária cresce com taxas diferentes. ^ref-7009

```
```ad-note
title: Location [491](kindle://book?action=open&asin=B07B61HC3L&location=491)
icon: location
color: 251 201 87

Por isso, não basta saber quanto tempo um algoritmo leva para ser executado – você precisa saber se o tempo de execução aumenta conforme a lista aumenta. É aí que a notação Big O entra. ^ref-2481

```
```ad-note
title: Location [494](kindle://book?action=open&asin=B07B61HC3L&location=494)
icon: location
color: 251 201 87

O não fornece o tempo em segundos. A notação Big O permite que você compare o número de operações. Ela informa o quão rapidamente um algoritmo cresce. ^ref-8920

```
```ad-note
title: Location [632](kindle://book?action=open&asin=B07B61HC3L&location=632)
icon: location
color: 251 201 87

feØffeeb é o endereço de um slot na memória. Cada vez que quer armazenar um item na memória, você pede ao computador um pouco de espaço e ele te dá um endereço no qual você pode armazenar o seu item. ^ref-62842

```
```ad-note
title: Location [640](kindle://book?action=open&asin=B07B61HC3L&location=640)
icon: location
color: 251 201 87

Usar um array significa que todas as suas tarefas estão armazenadas contiguamente (uma ao lado da outra) na memória. ^ref-20910

```
```ad-note
title: Location [680](kindle://book?action=open&asin=B07B61HC3L&location=680)
icon: location
color: 251 201 87

Mas se você quiser pular de um item para outro, as listas encadeadas são terríveis. ^ref-16518

```
```ad-note
title: Location [681](kindle://book?action=open&asin=B07B61HC3L&location=681)
icon: location
color: 251 201 87

Com arrays é diferente. Você sabe o endereço de cada item. ^ref-28082

```
```ad-note
title: Location [684](kindle://book?action=open&asin=B07B61HC3L&location=684)
icon: location
color: 251 201 87

Arrays são ótimos se você deseja ler elementos aleatórios, ^ref-1540

```
```ad-note
title: Location [689](kindle://book?action=open&asin=B07B61HC3L&location=689)
icon: location
color: 251 201 87

Os elementos em um array são numerados. Essa numeração começa no 0, ^ref-40284

```
```ad-note
title: Location [693](kindle://book?action=open&asin=B07B61HC3L&location=693)
icon: location
color: 251 201 87

posição de um elemento é chamada de índice. ^ref-39046

```
```ad-note
title: Location [696](kindle://book?action=open&asin=B07B61HC3L&location=696)
icon: location
color: 251 201 87

Aqui está o tempo de execução para operações comuns de arrays e listas. ^ref-3645

```
```ad-note
title: Location [711](kindle://book?action=open&asin=B07B61HC3L&location=711)
icon: location
color: 251 201 87

Usando listas encadeadas, basta mudar o endereço para o qual o elemento anterior está apontando. ^ref-58519

```
```ad-note
title: Location [716](kindle://book?action=open&asin=B07B61HC3L&location=716)
icon: location
color: 251 201 87

listas encadeadas são melhores caso você queira inserir um elemento no meio de uma lista. ^ref-26890

```
```ad-note
title: Location [717](kindle://book?action=open&asin=B07B61HC3L&location=717)
icon: location
color: 251 201 87

E se você quiser deletar um elemento? Novamente, é mais fácil fazer isso usando listas encadeadas, ^ref-14611

```
```ad-note
title: Location [723](kindle://book?action=open&asin=B07B61HC3L&location=723)
icon: location
color: 251 201 87

Vale a pena mencionar que inserções e eliminações terão tempo de execução O(1) somente se você puder acessar instantaneamente o elemento a ser deletado. É uma prática comum acompanhar o primeiro e o último item de uma lista encadeada para que o tempo de execução para deletá-los seja O(1). ^ref-62954

```
```ad-note
title: Location [725](kindle://book?action=open&asin=B07B61HC3L&location=725)
icon: location
color: 251 201 87

isso depende do caso em que se aplicam. Entretanto os arrays são mais comuns porque permitem acesso aleatório. Existem dois tipos de acesso: o aleatório e o sequencial. O sequencial significa ler os elementos, um por um, começando pelo primeiro. Listas encadeadas só podem lidar com acesso sequencial. Se você quiser ler o décimo elemento de uma lista encadeada, primeiro precisará ler os nove elementos anteriores para chegar ao endereço do décimo elemento. ^ref-61683

```
```ad-note
title: Location [730](kindle://book?action=open&asin=B07B61HC3L&location=730)
icon: location
color: 251 201 87

Arrays e listas são usados para implementar outras estruturas de dados (isso será explicado mais adiante). ^ref-65185

```
```ad-note
title: Location [774](kindle://book?action=open&asin=B07B61HC3L&location=774)
icon: location
color: 251 201 87

Então você tem uma operação com tempo de execução O(n) e precisa repetir essa operação n vezes: ^ref-58284

```
```ad-note
title: Location [843](kindle://book?action=open&asin=B07B61HC3L&location=843)
icon: location
color: 251 201 87

uma maneira elegante de solucionar problemas. ^ref-46353

```
```ad-note
title: Location [885](kindle://book?action=open&asin=B07B61HC3L&location=885)
icon: location
color: 251 201 87

Recursão é quando uma função chama a si mesma. ^ref-35508

```
```ad-note
title: Location [897](kindle://book?action=open&asin=B07B61HC3L&location=897)
icon: location
color: 251 201 87

recursão é usada para tornar a resposta mais clara. ^ref-38622

```
```ad-note
title: Location [899](kindle://book?action=open&asin=B07B61HC3L&location=899)
icon: location
color: 251 201 87

“Os loops podem melhorar o desempenho do seu programa. A recursão melhora o desempenho do seu programador. Escolha o que for mais importante para a sua situação.”1 ^ref-22863

```
```ad-note
title: Location [904](kindle://book?action=open&asin=B07B61HC3L&location=904)
icon: location
color: 251 201 87

Devido ao fato de a função recursiva chamar a si mesma, é mais fácil escrevê-la erroneamente e acabar em um loop infinito. ^ref-52218

```
```ad-note
title: Location [915](kindle://book?action=open&asin=B07B61HC3L&location=915)
icon: location
color: 251 201 87

Quando você escreve uma função recursiva, deve informar quando a recursão deve parar. É por isso que toda função recursiva tem duas partes: o caso-base e o caso recursivo. O caso recursivo é quando a função chama a si mesma. O caso-base é quando a função não chama a si mesma novamente, de forma que o programa não se torna um loop infinito. ^ref-30286

```
```ad-note
title: Location [937](kindle://book?action=open&asin=B07B61HC3L&location=937)
icon: location
color: 251 201 87

Quando você lê um item, lê apenas o item do topo da pilha e ele é retirado da lista. Logo, sua lista de afazeres contém apenas duas ações: push (inserir) e pop (remover e ler). ^ref-40939

```
```ad-note
title: Location [941](kindle://book?action=open&asin=B07B61HC3L&location=941)
icon: location
color: 251 201 87

Esta estrutura de dados é chamada de pilha. A pilha é uma estrutura de dados simples. ^ref-19116

```
```ad-note
title: Location [965](kindle://book?action=open&asin=B07B61HC3L&location=965)
icon: location
color: 251 201 87

Cada vez que você faz uma chamada de função, seu computador salva na memória os valores para todas as variáveis. ^ref-19193

```
```ad-note
title: Location [969](kindle://book?action=open&asin=B07B61HC3L&location=969)
icon: location
color: 251 201 87

segunda caixa é adicionada em cima da primeira. ^ref-31743

```
```ad-note
title: Location [974](kindle://book?action=open&asin=B07B61HC3L&location=974)
icon: location
color: 251 201 87

quando você chama uma função a partir de outra, a chamada de função fica pausada em um estado parcialmente completo. ^ref-39489

```
```ad-note
title: Location [975](kindle://book?action=open&asin=B07B61HC3L&location=975)
icon: location
color: 251 201 87

Todos os valores das variáveis para aquela função ainda estão armazenados na memória. ^ref-51702

```
```ad-note
title: Location [983](kindle://book?action=open&asin=B07B61HC3L&location=983)
icon: location
color: 251 201 87

Essa pilha usada para guardar as variáveis de múltiplas funções é denominada pilha de chamada. ^ref-6601

```
```ad-note
title: Location [989](kindle://book?action=open&asin=B07B61HC3L&location=989)
icon: location
color: 251 201 87

As funções recursivas também utilizam a pilha de chamada! ^ref-56378

```
```ad-note
title: Location [1018](kindle://book?action=open&asin=B07B61HC3L&location=1018)
icon: location
color: 251 201 87

Usar a pilha é bom, porém, existe um custo: salvar toda essa informação pode ocupar muita memória. ^ref-35027

```
```ad-note
title: Location [1020](kindle://book?action=open&asin=B07B61HC3L&location=1020)
icon: location
color: 251 201 87

Para esta situação, você tem duas opções: • Reescrever seu código utilizando loops. • Utilizar o que chamamos de tail recursion (recursão de cauda). Isto é um tópico avançado em recursão e está fora do escopo deste livro. Esta técnica também não é suportada por todas as linguagens de programação. ^ref-3910

```
```ad-note
title: Location [1046](kindle://book?action=open&asin=B07B61HC3L&location=1046)
icon: location
color: 251 201 87

técnica dividir para conquistar (DC), uma técnica recursiva muito conhecida para resolução de problemas. ^ref-45502

```
```ad-note
title: Location [1062](kindle://book?action=open&asin=B07B61HC3L&location=1062)
icon: location
color: 251 201 87

Os algoritmos DC são recursivos. ^ref-14146

```
```ad-note
title: Location [1071](kindle://book?action=open&asin=B07B61HC3L&location=1071)
icon: location
color: 251 201 87

Seguindo a estratégia DC, a cada recursão você deve reduzir o seu problema. ^ref-49261

```
```ad-note
title: Location [1101](kindle://book?action=open&asin=B07B61HC3L&location=1101)
icon: location
color: 251 201 87

O algoritmo DC não é um simples algoritmo que você aplica em um problema, mas sim uma maneira de pensar sobre o problema. ^ref-36848

```
```ad-note
title: Location [1128](kindle://book?action=open&asin=B07B61HC3L&location=1128)
icon: location
color: 251 201 87

Dica Quando estiver escrevendo uma função de recursão que envolva um array, o caso-base será, muitas vezes, um array vazio ou um array com apenas um elemento. ^ref-4617

```
```ad-note
title: Location [1158](kindle://book?action=open&asin=B07B61HC3L&location=1158)
icon: location
color: 251 201 87

O quicksort é um algoritmo de ordenação. ^ref-1776

```
```ad-note
title: Location [1221](kindle://book?action=open&asin=B07B61HC3L&location=1221)
icon: location
color: 251 201 87

Cada prova por indução segue dois passos: o caso-base e o caso indutivo. ^ref-61983

```
```ad-note
title: Location [1228](kindle://book?action=open&asin=B07B61HC3L&location=1228)
icon: location
color: 251 201 87

provas por indução, mas elas são divertidas e andam lado a lado com a estratégia DC. ^ref-40754

```
```ad-note
title: Location [1250](kindle://book?action=open&asin=B07B61HC3L&location=1250)
icon: location
color: 251 201 87

O algoritmo quicksort é único, pois sua velocidade depende do pivô escolhido. ^ref-23241

```
```ad-note
title: Location [1256](kindle://book?action=open&asin=B07B61HC3L&location=1256)
icon: location
color: 251 201 87

Na realidade, o seu computador é capaz de executar muito mais do que dez operações por segundo. ^ref-27608

```
```ad-note
title: Location [1261](kindle://book?action=open&asin=B07B61HC3L&location=1261)
icon: location
color: 251 201 87

O algoritmo quicksort é um caso complicado. Na pior situação, o quicksort tem tempo de execução O(n2). Ele é tão lento quanto a ordenação por seleção! Porém este é o pior caso possível. No caso médio, o quicksort tem tempo de execução O(n log n). ^ref-29274

```
```ad-note
title: Location [1306](kindle://book?action=open&asin=B07B61HC3L&location=1306)
icon: location
color: 251 201 87

desempenho do quicksort depende bastante da escolha do pivô. ^ref-62345

```
```ad-note
title: Location [1316](kindle://book?action=open&asin=B07B61HC3L&location=1316)
icon: location
color: 251 201 87

No pior caso, o tamanho da pilha é O(n). No melhor caso, o tamanho da pilha é O(log n). ^ref-62500

```
```ad-note
title: Location [1332](kindle://book?action=open&asin=B07B61HC3L&location=1332)
icon: location
color: 251 201 87

algoritmo quicksort é um dos mais rápidos algoritmos de ordenação que existem, sendo um ótimo exemplo de DC. ^ref-42317

```
```ad-note
title: Location [1382](kindle://book?action=open&asin=B07B61HC3L&location=1382)
icon: location
color: 251 201 87

Uma função hash é uma função na qual você insere uma string1 e, depois disso, a função retorna um número. ^ref-4337

```
```ad-note
title: Location [1386](kindle://book?action=open&asin=B07B61HC3L&location=1386)
icon: location
color: 251 201 87

função hash “mapeia strings e números”. ^ref-62200

```
```ad-note
title: Location [1388](kindle://book?action=open&asin=B07B61HC3L&location=1388)
icon: location
color: 251 201 87

Ela deve ser consistente. ^ref-57446

```
```ad-note
title: Location [1390](kindle://book?action=open&asin=B07B61HC3L&location=1390)
icon: location
color: 251 201 87

função deve mapear diferentes palavras para diferentes números. ^ref-26668

```
```ad-note
title: Location [1418](kindle://book?action=open&asin=B07B61HC3L&location=1418)
icon: location
color: 251 201 87

Coloque uma função hash em conjunto com um array e você terá uma estrutura de dados chamada tabela hash. ^ref-11804

```
```ad-note
title: Location [1419](kindle://book?action=open&asin=B07B61HC3L&location=1419)
icon: location
color: 251 201 87

Uma tabela hash é a primeira estrutura de dados que tem uma lógica adicional aliada ^ref-10339

```
```ad-note
title: Location [1421](kindle://book?action=open&asin=B07B61HC3L&location=1421)
icon: location
color: 251 201 87

As tabelas hash são, provavelmente, as mais úteis e complexas estruturas de dados que você aprenderá. ^ref-51839

```
```ad-note
title: Location [1422](kindle://book?action=open&asin=B07B61HC3L&location=1422)
icon: location
color: 251 201 87

Elas também são conhecidas como mapas hash, mapas, dicionários e tabelas de dispersão. ^ref-11914

```
```ad-note
title: Location [1425](kindle://book?action=open&asin=B07B61HC3L&location=1425)
icon: location
color: 251 201 87

Você provavelmente nunca terá de implementar uma tabela hash, pois qualquer linguagem de programação já terá uma implementação dela. ^ref-31889

```
```ad-note
title: Location [1443](kindle://book?action=open&asin=B07B61HC3L&location=1443)
icon: location
color: 251 201 87

Uma tabela hash contém chaves e valores. ^ref-27829

```
```ad-note
title: Location [1488](kindle://book?action=open&asin=B07B61HC3L&location=1488)
icon: location
color: 251 201 87

As tabelas hash tornam simples a modelagem de uma relação entre dois itens. ^ref-13976

```
```ad-note
title: Location [1495](kindle://book?action=open&asin=B07B61HC3L&location=1495)
icon: location
color: 251 201 87

resolução DNS, e as tabelas hash são uma das maneiras pelas quais esta funcionalidade pode ser implementada. ^ref-54252

```
```ad-note
title: Location [1617](kindle://book?action=open&asin=B07B61HC3L&location=1617)
icon: location
color: 251 201 87

• A função hash é muito importante. Ela mapeia todas as chaves para um único espaço. Idealmente, a sua função hash mapearia chaves de maneira simétrica por toda a hash. • Caso as listas encadeadas se tornem muito longas, elas diminuirão demais o tempo de execução da tabela hash. Porém elas não se tornarão muito longas se você utilizar uma boa função hash! ^ref-50147

```
```ad-note
title: Location [1621](kindle://book?action=open&asin=B07B61HC3L&location=1621)
icon: location
color: 251 201 87

pois uma boa função hash cria poucas colisões. ^ref-21778

```
```ad-note
title: Location [1634](kindle://book?action=open&asin=B07B61HC3L&location=1634)
icon: location
color: 251 201 87

pois o retorno da tabela hash sempre levará a mesma quantidade de tempo. ^ref-21338

```
```ad-note
title: Location [1640](kindle://book?action=open&asin=B07B61HC3L&location=1640)
icon: location
color: 251 201 87

As tabelas hash são tão velozes quanto os arrays na busca (pegar um valor em algum índice), e elas são tão velozes quanto as listas na inserção e na remoção de itens. ^ref-52981

```
```ad-note
title: Location [1642](kindle://book?action=open&asin=B07B61HC3L&location=1642)
icon: location
color: 251 201 87

Assim, é importante que você não opere no pior caso; para isso é preciso evitar colisões. Para evitar colisões são necessários • um baixo fator de carga; • uma boa função hash. ^ref-53070

```
```ad-note
title: Location [2684](kindle://book?action=open&asin=B07B61HC3L&location=2684)
icon: location
color: 251 201 87

O algoritmo mais simples é o seguinte: você deve testar para todos os conjuntos de itens possíveis e descobrir qual conjunto maximizará o valor roubado. ^ref-28184

```
```ad-note
title: Location [2686](kindle://book?action=open&asin=B07B61HC3L&location=2686)
icon: location
color: 251 201 87

Isto funciona, mas é uma solução muito lenta, ^ref-913

```
```ad-note
title: Location [2694](kindle://book?action=open&asin=B07B61HC3L&location=2694)
icon: location
color: 251 201 87

Ele começa com a resolução de subproblemas e vai escalando-os até resolver o problema geral. ^ref-27110

```
```ad-note
title: Location [2695](kindle://book?action=open&asin=B07B61HC3L&location=2695)
icon: location
color: 251 201 87

No problema da mochila, você começaria resolvendo o problema para mochilas menores (ou “submochilas”) e iria escalando estes problemas até resolver o problema original. ^ref-53200

```
```ad-note
title: Location [2700](kindle://book?action=open&asin=B07B61HC3L&location=2700)
icon: location
color: 251 201 87

Cada algoritmo de programação dinâmica começa com uma tabela. ^ref-16276

```
```ad-note
title: Location [2704](kindle://book?action=open&asin=B07B61HC3L&location=2704)
icon: location
color: 251 201 87

A tabela começa vazia, mas você preencherá cada célula dela. ^ref-4761

```
```ad-note
title: Location [2732](kindle://book?action=open&asin=B07B61HC3L&location=2732)
icon: location
color: 251 201 87

Em cada linha, será possível roubar o item relativo àquela linha e todos os itens das linhas anteriores. ^ref-41040

```
```ad-note
title: Location [2771](kindle://book?action=open&asin=B07B61HC3L&location=2771)
icon: location
color: 251 201 87

Cada célula é calculada com a mesma fórmula, ^ref-20698

```
```ad-note
title: Location [2801](kindle://book?action=open&asin=B07B61HC3L&location=2801)
icon: location
color: 251 201 87

A cada iteração, você armazenará a estimativa máxima atual. ^ref-26555

```
```ad-note
title: Location [2802](kindle://book?action=open&asin=B07B61HC3L&location=2802)
icon: location
color: 251 201 87

A estimativa nunca poderá ficar abaixo do que ela já é! ^ref-41637

```
```ad-note
title: Location [2808](kindle://book?action=open&asin=B07B61HC3L&location=2808)
icon: location
color: 251 201 87

A resposta não muda. Logo, a ordem das linhas não importa. ^ref-62649

```
```ad-note
title: Location [2848](kindle://book?action=open&asin=B07B61HC3L&location=2848)
icon: location
color: 251 201 87

a programação dinâmica só funciona quando os seus subproblemas são discretos, ou seja, quando eles não são dependentes entre si. ^ref-9640

```
```ad-note
title: Location [2869](kindle://book?action=open&asin=B07B61HC3L&location=2869)
icon: location
color: 251 201 87

A programação dinâmica é útil quando você está tentando otimizar em relação a um limite ^ref-23939

```
```ad-note
title: Location [2871](kindle://book?action=open&asin=B07B61HC3L&location=2871)
icon: location
color: 251 201 87

Você pode utilizar a programação dinâmica quando o problema puder ser separado em subproblemas discretos ^ref-24226

```
```ad-note
title: Location [2873](kindle://book?action=open&asin=B07B61HC3L&location=2873)
icon: location
color: 251 201 87

Toda solução de programação dinâmica envolve uma tabela. ^ref-11288

```
```ad-note
title: Location [2876](kindle://book?action=open&asin=B07B61HC3L&location=2876)
icon: location
color: 251 201 87

Cada célula é um subproblema, ^ref-22184

```
```ad-note
title: Location [2876](kindle://book?action=open&asin=B07B61HC3L&location=2876)
icon: location
color: 251 201 87

pense em como você pode dividi-lo em outros subproblemas, ^ref-39752

```
```ad-note
title: Location [2891](kindle://book?action=open&asin=B07B61HC3L&location=2891)
icon: location
color: 251 201 87

Em programação dinâmica, tentamos maximizar algo. ^ref-56211

```
```ad-note
title: Location [2893](kindle://book?action=open&asin=B07B61HC3L&location=2893)
icon: location
color: 251 201 87

Lembre-se: os valores das células são o que você geralmente está tentando otimizar. ^ref-55779

```
```ad-note
title: Location [2896](kindle://book?action=open&asin=B07B61HC3L&location=2896)
icon: location
color: 251 201 87

Cada célula conterá o comprimento da maior substring que duas substrings têm em comum. ^ref-9805

```
```ad-note
title: Location [2906](kindle://book?action=open&asin=B07B61HC3L&location=2906)
icon: location
color: 251 201 87

algoritmo de Feynman ^ref-27852

```
```ad-note
title: Location [2911](kindle://book?action=open&asin=B07B61HC3L&location=2911)
icon: location
color: 251 201 87

Às vezes, algoritmos não são uma receita exata, mas sim uma estrutura na qual você constrói a sua ideia. ^ref-14596

```
```ad-note
title: Location [2931](kindle://book?action=open&asin=B07B61HC3L&location=2931)
icon: location
color: 251 201 87

a solução final pode não estar na última célula! Para o problema da mochila, a última célula sempre retornaria a solução final, mas para a maior substring comum, a solução será o maior número da tabela, que pode não estar na última célula. ^ref-28062

```
```ad-note
title: Location [2943](kindle://book?action=open&asin=B07B61HC3L&location=2943)
icon: location
color: 251 201 87

deveria comparar a maior subsequência comum, que é o número de letras em sequência que duas palavras têm em comum. ^ref-7179

```
```ad-note
title: Location [2963](kindle://book?action=open&asin=B07B61HC3L&location=2963)
icon: location
color: 251 201 87

Biólogos utilizam a maior subsequência comum para encontrar similaridades em fitas de DNA, para então dizer o quão semelhante são dois animais ou duas doenças. A maior subsequência comum está sendo usada para encontrar a cura para a esclerose múltipla. ^ref-17071

```
```ad-note
title: Location [2966](kindle://book?action=open&asin=B07B61HC3L&location=2966)
icon: location
color: 251 201 87

diferença entre dois arquivos usando programação dinâmica para isso. ^ref-59640

```
```ad-note
title: Location [2967](kindle://book?action=open&asin=B07B61HC3L&location=2967)
icon: location
color: 251 201 87

A distância Levenshtein mede o quão similar são duas strings usando também a programação dinâmica. ^ref-19394

```
```ad-note
title: Location [2968](kindle://book?action=open&asin=B07B61HC3L&location=2968)
icon: location
color: 251 201 87

utilizada tanto para simples corretores ortográficos quanto para descobrir se um usuário está fazendo upload de dados com direitos autorais associados. ^ref-694

```
```ad-note
title: Location [2980](kindle://book?action=open&asin=B07B61HC3L&location=2980)
icon: location
color: 251 201 87

Não existe uma fórmula única para calcular uma solução em programação dinâmica. ^ref-64436

```
```ad-note
title: Location [3022](kindle://book?action=open&asin=B07B61HC3L&location=3022)
icon: location
color: 251 201 87

você agrupa os usuários por similaridade, mas como faz para descobrir o quão semelhante dois usuários são? ^ref-58043

```
```ad-note
title: Location [3024](kindle://book?action=open&asin=B07B61HC3L&location=3024)
icon: location
color: 251 201 87

No exemplo da toranja, compararam-se as frutas baseando-se em seu tamanho e sua cor. Ou seja, o tamanho e a cor são as características que você está comparando. ^ref-46268

```
```ad-note
title: Location [3031](kindle://book?action=open&asin=B07B61HC3L&location=3031)
icon: location
color: 251 201 87

Lembre-se de que para encontrar a distância entre dois pontos utilizamos o teorema de Pitágoras. ^ref-51675

```
```ad-note
title: Location [3039](kindle://book?action=open&asin=B07B61HC3L&location=3039)
icon: location
color: 251 201 87

Agora, suponha que você esteja comparando usuários do Netflix. Para isso é necessário criar o gráfico de usuários de alguma maneira e converter cada usuário em um conjunto de coordenadas, assim como fizemos com a fruta. ^ref-31208

```
```ad-note
title: Location [3054](kindle://book?action=open&asin=B07B61HC3L&location=3054)
icon: location
color: 251 201 87

Porém agora ela envolve um conjunto de cinco números em vez de apenas dois números. A fórmula da distância é flexível: você poderia ter um conjunto de milhões de números e ainda assim usar a mesma fórmula ^ref-52778

```
```ad-note
title: Location [3056](kindle://book?action=open&asin=B07B61HC3L&location=3056)
icon: location
color: 251 201 87

“O que a distância significa quando temos cinco números?”. A distância informa a similaridade entre estes conjuntos. ^ref-48513

```
```ad-note
title: Location [3076](kindle://book?action=open&asin=B07B61HC3L&location=3076)
icon: location
color: 251 201 87

você deseja adivinhar como Priyanka avaliará determinado filme. ^ref-10728

```
```ad-note
title: Location [3085](kindle://book?action=open&asin=B07B61HC3L&location=3085)
icon: location
color: 251 201 87

Seria possível utilizar a média das avaliações deles, que é 4,2 estrelas. Isso é chamado de regressão ^ref-10906

```
```ad-note
title: Location [3106](kindle://book?action=open&asin=B07B61HC3L&location=3106)
icon: location
color: 251 201 87

similaridade de cosseno ^ref-34803

```
```ad-note
title: Location [3109](kindle://book?action=open&asin=B07B61HC3L&location=3109)
icon: location
color: 251 201 87

A similaridade de cosseno não mede a distância entre dois vetores, em vez disso, compara o ângulo entre dois vetores. ^ref-18657

```
```ad-note
title: Location [3120](kindle://book?action=open&asin=B07B61HC3L&location=3120)
icon: location
color: 251 201 87

Ao trabalhar com o algoritmo dos k-vizinhos mais próximos, é muito importante escolher as características certas a serem comparadas, ^ref-7087

```
```ad-note
title: Location [3129](kindle://book?action=open&asin=B07B61HC3L&location=3129)
icon: location
color: 251 201 87

Quando o assunto é escolher boas características, não existe apenas uma resposta correta, pois é preciso pensar sobre todos os diferentes aspectos que devem ser considerados. ^ref-53628

```
```ad-note
title: Location [3135](kindle://book?action=open&asin=B07B61HC3L&location=3135)
icon: location
color: 251 201 87

O algoritmo dos k-vizinhos mais próximos é muito útil e é a sua introdução ao mundo mágico do aprendizado de máquina! ^ref-48956

```
```ad-note
title: Location [3138](kindle://book?action=open&asin=B07B61HC3L&location=3138)
icon: location
color: 251 201 87

O OCR é um acrônimo para optical character recognition (reconhecimento óptico de caracteres). ^ref-4785

```
```ad-note
title: Location [3139](kindle://book?action=open&asin=B07B61HC3L&location=3139)
icon: location
color: 251 201 87

Com o OCR é possível fotografar um texto fazendo com que o seu computador leia este texto a partir da imagem. ^ref-25094

```
```ad-note
title: Location [3147](kindle://book?action=open&asin=B07B61HC3L&location=3147)
icon: location
color: 251 201 87

De um modo geral, algoritmos OCR medem linhas, pontos e curvas. ^ref-12521

```
```ad-note
title: Location [3154](kindle://book?action=open&asin=B07B61HC3L&location=3154)
icon: location
color: 251 201 87

A primeira etapa do OCR, onde você percorre todas as imagens de números e extrai as características, é chamada de treinamento ^ref-20459

```
```ad-note
title: Location [3158](kindle://book?action=open&asin=B07B61HC3L&location=3158)
icon: location
color: 251 201 87

Os filtros de spam utilizam outro algoritmo simples chamado de classificador Naive Bayes. ^ref-17077

```
```ad-note
title: Location [3159](kindle://book?action=open&asin=B07B61HC3L&location=3159)
icon: location
color: 251 201 87

primeiro treinamos o classificador Naive Bayes com alguns dados. ^ref-46912

```
```ad-note
title: Location [3195](kindle://book?action=open&asin=B07B61HC3L&location=3195)
icon: location
color: 251 201 87

estrutura de dados árvore binária de busca ^ref-17366

```
```ad-note
title: Location [3211](kindle://book?action=open&asin=B07B61HC3L&location=3211)
icon: location
color: 251 201 87

Porém a árvore binária de busca é muito mais rápida para inserções e remoções, ^ref-22983

```
```ad-note
title: Location [3213](kindle://book?action=open&asin=B07B61HC3L&location=3213)
icon: location
color: 251 201 87

Entretanto a árvore binária de busca tem algumas desvantagens: ^ref-22381

```
```ad-note
title: Location [3213](kindle://book?action=open&asin=B07B61HC3L&location=3213)
icon: location
color: 251 201 87

não é possível utilizar acesso aleatório. ^ref-38085

```
```ad-note
title: Location [3214](kindle://book?action=open&asin=B07B61HC3L&location=3214)
icon: location
color: 251 201 87

o bom desempenho relacionado ao tempo de execução não acontece em todos os casos, mas sim em uma média, e este tempo de execução é fortemente dependente da necessidade de a árvore ser balanceada. ^ref-61647

```
```ad-note
title: Location [3219](kindle://book?action=open&asin=B07B61HC3L&location=3219)
icon: location
color: 251 201 87

Existem árvores binárias de busca especiais que se balanceiam automaticamente. ^ref-40875

```
```ad-note
title: Location [3221](kindle://book?action=open&asin=B07B61HC3L&location=3221)
icon: location
color: 251 201 87

As Árvores B, um tipo especial de árvore binária, são comumente usadas para armazenar dados em bancos de dados. ^ref-30311

```
```ad-note
title: Location [3236](kindle://book?action=open&asin=B07B61HC3L&location=3236)
icon: location
color: 251 201 87

Esta é uma estrutura de dados muito útil: uma hash que mapeia palavras para lugares onde elas aparecem. Esta estrutura de dados é chamada de índice invertido e é muito usada na construção de ferramentas de busca. ^ref-23458

```
```ad-note
title: Location [3239](kindle://book?action=open&asin=B07B61HC3L&location=3239)
icon: location
color: 251 201 87

A transformada de Fourier é um dos raros algoritmos que conseguem ser brilhantes, elegantes e ter milhares de formas de utilização. ^ref-32720

```
```ad-note
title: Location [3243](kindle://book?action=open&asin=B07B61HC3L&location=3243)
icon: location
color: 251 201 87

Em outras palavras, dada uma música, a transformada a separará em frequências individuais. ^ref-32874

```
```ad-note
title: Location [3246](kindle://book?action=open&asin=B07B61HC3L&location=3246)
icon: location
color: 251 201 87

A transformada de Fourier é uma ótima ferramenta para o processamento de sinais. Além disso, ela pode ser utilizada na compressão de músicas. ^ref-50701

```
```ad-note
title: Location [3247](kindle://book?action=open&asin=B07B61HC3L&location=3247)
icon: location
color: 251 201 87

Então, a transformada de Fourier informa o quanto exatamente cada nota contribui para a música como um todo. Sabendo disso é possível eliminar notas que não são importantes para a música. Este é o modo de funcionamento do formato MP3! ^ref-47860

```
```ad-note
title: Location [3250](kindle://book?action=open&asin=B07B61HC3L&location=3250)
icon: location
color: 251 201 87

O formato JPG é outro formato comprimido que funciona da mesma maneira. A transformada de Fourier também é usada para tentar prever terremotos e analisar DNA. ^ref-4256

```
```ad-note
title: Location [3251](kindle://book?action=open&asin=B07B61HC3L&location=3251)
icon: location
color: 251 201 87

Você pode usá-la para desenvolver um aplicativo como o Shazam, que identifica qual música está tocando. A transformada de Fourier tem diversas finalidades, e são altas as chances de você se deparar com ela. ^ref-19788

```
```ad-note
title: Location [3257](kindle://book?action=open&asin=B07B61HC3L&location=3257)
icon: location
color: 251 201 87

Para que o seu algoritmo se torne mais rápido, é necessário fazer com que ele seja executado paralelamente, em todos os núcleos de uma só vez! ^ref-51665

```
```ad-note
title: Location [3258](kindle://book?action=open&asin=B07B61HC3L&location=3258)
icon: location
color: 251 201 87

O melhor desempenho possível para um algoritmo de ordenação é aproximadamente O(n log n). ^ref-39658

```
```ad-note
title: Location [3259](kindle://book?action=open&asin=B07B61HC3L&location=3259)
icon: location
color: 251 201 87

Sabemos também que não é possível ordenar um array em tempo de execução O(n), a menos que seja utilizado um algoritmo paralelo! ^ref-53879

```
```ad-note
title: Location [3260](kindle://book?action=open&asin=B07B61HC3L&location=3260)
icon: location
color: 251 201 87

Há uma versão paralela do quicksort que consegue ordenar um array com tempo de execução O(n). ^ref-32790

```
```ad-note
title: Location [3261](kindle://book?action=open&asin=B07B61HC3L&location=3261)
icon: location
color: 251 201 87

Algoritmos paralelos são difíceis de projetar, além de ser difícil fazer com que funcionem corretamente e também estimar o incremento de velocidade que fornecerão. ^ref-5130

```
```ad-note
title: Location [3272](kindle://book?action=open&asin=B07B61HC3L&location=3272)
icon: location
color: 251 201 87

Existe um tipo especial de algoritmo paralelo que está se tornando muito popular: o algoritmo distribuído ^ref-10223

```
```ad-note
title: Location [3274](kindle://book?action=open&asin=B07B61HC3L&location=3274)
icon: location
color: 251 201 87

é possível escrever o seu algoritmo para ser executado por diversas máquinas. O algoritmo MapReduce é um algoritmo distribuído popular que pode ser usado no framework livre Apache Hadoop. ^ref-49530

```
```ad-note
title: Location [3282](kindle://book?action=open&asin=B07B61HC3L&location=3282)
icon: location
color: 251 201 87

O MapReduce, em particular, é baseado em duas ideias simples: a função map (mapa) e a função reduce (reduzir). ^ref-23730

```
```ad-note
title: Location [3285](kindle://book?action=open&asin=B07B61HC3L&location=3285)
icon: location
color: 251 201 87

ela pega um array e aplica a mesma função para cada item no array. ^ref-17498

```
```ad-note
title: Location [3303](kindle://book?action=open&asin=B07B61HC3L&location=3303)
icon: location
color: 251 201 87

pois a ideia central desta função é “reduzir” uma lista inteira para apenas um item. ^ref-58900

```
```ad-note
title: Location [3338](kindle://book?action=open&asin=B07B61HC3L&location=3338)
icon: location
color: 251 201 87

Eles são estruturas de dados probabilísticas que fornecem uma resposta que pode estar errada, mas que provavelmente estará correta. ^ref-32397

```
```ad-note
title: Location [3344](kindle://book?action=open&asin=B07B61HC3L&location=3344)
icon: location
color: 251 201 87

Os filtros de bloom são ótimos porque eles usam pouco espaço. ^ref-30939

```
```ad-note
title: Location [3348](kindle://book?action=open&asin=B07B61HC3L&location=3348)
icon: location
color: 251 201 87

Imagine que a Google deseja contabilizar o número de pesquisas únicas realizadas por seus usuários, ^ref-33907

```
```ad-note
title: Location [3352](kindle://book?action=open&asin=B07B61HC3L&location=3352)
icon: location
color: 251 201 87

O HyperLogLog aproxima o número de elementos únicos em um conjunto. Assim como o filtro de bloom, ele não fornecerá uma resposta exata, mas se aproximará muito desta, usando apenas uma fração da memória de que a tarefa necessitaria se fosse implementada da maneira tradicional. ^ref-4167

```
```ad-note
title: Location [3367](kindle://book?action=open&asin=B07B61HC3L&location=3367)
icon: location
color: 251 201 87

Outra função hash é uma função de algoritmo de hash seguro (do inglês Secure Hash Algorithm – SHA). Dada uma string, o SHA retorna uma hash para esta string. ^ref-21529

```
```ad-note
title: Location [3369](kindle://book?action=open&asin=B07B61HC3L&location=3369)
icon: location
color: 251 201 87

A terminologia pode parecer um pouco confusa neste ponto. O SHA é uma função hash. Ele gera um hash, que é apenas uma string curta. A função hash faz a ligação entre string e índice de arrays, enquanto o SHA faz a ligação entre string e string. ^ref-18862

```
```ad-note
title: Location [3376](kindle://book?action=open&asin=B07B61HC3L&location=3376)
icon: location
color: 251 201 87

Você pode utilizar o SHA para verificar se dois arquivos são iguais. ^ref-27727

```
```ad-note
title: Location [3381](kindle://book?action=open&asin=B07B61HC3L&location=3381)
icon: location
color: 251 201 87

O SHA é útil também quando você quer comparar string sem revelar a string original. ^ref-38355

```
```ad-note
title: Location [3383](kindle://book?action=open&asin=B07B61HC3L&location=3383)
icon: location
color: 251 201 87

A Google não armazena a senha original, mas apenas a hash SHA da senha! Quando você digita a sua senha, a Google verifica a hash do que você digitou e a compara com o que está no banco de dados. ^ref-45108

```
```ad-note
title: Location [3389](kindle://book?action=open&asin=B07B61HC3L&location=3389)
icon: location
color: 251 201 87

No entanto não é possível descobrir a string original a partir da hash. ^ref-41778

```
```ad-note
title: Location [3392](kindle://book?action=open&asin=B07B61HC3L&location=3392)
icon: location
color: 251 201 87

Ou seja, você pode converter uma senha em uma hash, mas não consegue fazer o processo inverso. ^ref-46409

```
```ad-note
title: Location [3397](kindle://book?action=open&asin=B07B61HC3L&location=3397)
icon: location
color: 251 201 87

O algoritmo SHA tem outra característica importante: ele é localmente insensitivo. ^ref-58944

```
```ad-note
title: Location [3399](kindle://book?action=open&asin=B07B61HC3L&location=3399)
icon: location
color: 251 201 87

Se você modificar apenas um caractere e recalcular a hash, ela será totalmente diferente! ^ref-36777

```
```ad-note
title: Location [3402](kindle://book?action=open&asin=B07B61HC3L&location=3402)
icon: location
color: 251 201 87

Isto é bom porque não será possível comparar as hashes para verificar se a senha está perto de ser quebrada. ^ref-19626

```
```ad-note
title: Location [3403](kindle://book?action=open&asin=B07B61HC3L&location=3403)
icon: location
color: 251 201 87

função hash localmente sensitiva. É aí que a Simhash entra. Caso você faça uma pequena mudança na string, a Simhash criará uma hash que é levemente diferente. Isto permite que você compare ambas as hashes geradas para verificar o quão semelhantes elas são, o que é muito útil! ^ref-6044

```
```ad-note
title: Location [3410](kindle://book?action=open&asin=B07B61HC3L&location=3410)
icon: location
color: 251 201 87

O Simhash é útil quando você quer verificar itens similares. ^ref-56726

```
```ad-note
title: Location [3413](kindle://book?action=open&asin=B07B61HC3L&location=3413)
icon: location
color: 251 201 87

resolve um problema muito antigo de uma maneira elegante. ^ref-38229

```
```ad-note
title: Location [3426](kindle://book?action=open&asin=B07B61HC3L&location=3426)
icon: location
color: 251 201 87

A troca de chaves Diffie-Hellman resolve ambos os problemas: • Ambas as partes não precisam saber da cifra. Assim, não precisamos nos encontrar para combinar que cifra utilizar. • As mensagens encriptadas são extremamente difíceis de ser decodificadas. ^ref-552

```
```ad-note
title: Location [3429](kindle://book?action=open&asin=B07B61HC3L&location=3429)
icon: location
color: 251 201 87

A troca de chaves Diffie-Hellman contém duas chaves: uma chave pública e uma chave privada. ^ref-47352

```
```ad-note
title: Location [3431](kindle://book?action=open&asin=B07B61HC3L&location=3431)
icon: location
color: 251 201 87

Quando alguém quiser enviar uma mensagem, ele a encripta usando a chave pública. ^ref-56440

```
```ad-note
title: Location [3431](kindle://book?action=open&asin=B07B61HC3L&location=3431)
icon: location
color: 251 201 87

decodificada apenas com a utilização de uma chave privada. ^ref-13912

```
```ad-note
title: Location [3433](kindle://book?action=open&asin=B07B61HC3L&location=3433)
icon: location
color: 251 201 87

O algoritmo de Diffie-Hellman ainda é usado na prática, em conjunto com o seu sucessor, o RSA. Se você se interessar por criptografia, ^ref-37813

```
```ad-note
title: Location [3436](kindle://book?action=open&asin=B07B61HC3L&location=3436)
icon: location
color: 251 201 87

A programação linear é usada para maximizar algo em relação a um limite. ^ref-21584

```
```ad-note
title: Location [3440](kindle://book?action=open&asin=B07B61HC3L&location=3440)
icon: location
color: 251 201 87

Neste exemplo você está tentando maximizar o lucro, enquanto seus limites são a quantidade de material disponível. ^ref-61201

```
```ad-note
title: Location [3446](kindle://book?action=open&asin=B07B61HC3L&location=3446)
icon: location
color: 251 201 87

Aqui você está tentando maximizar votos, considerando como limites o tempo e o dinheiro. ^ref-52211

```
```ad-note
title: Location [3448](kindle://book?action=open&asin=B07B61HC3L&location=3448)
icon: location
color: 251 201 87

Todos os algoritmos de grafos podem ser feitos por meio de programação linear. A programação linear é um framework muito mais geral, ^ref-7929

```
```ad-note
title: Location [3450](kindle://book?action=open&asin=B07B61HC3L&location=3450)
icon: location
color: 251 201 87

A programação linear utiliza o algoritmo Simplex, que é um algoritmo complexo. ^ref-60509

```
```ad-note
title: Location [3707](kindle://book?action=open&asin=B07B61HC3L&location=3707)
icon: location
color: 251 201 87

Uma boa regra é a seguinte: se você tem N usuários, deve considerar sqrt(N) vizinhos. ^ref-5820

```
